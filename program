#!/usr/bin/env escript

% http://erlang.org/pipermail/erlang-questions/2017-August/093012.html
-mode(compile).

main([Pattern]) ->
    case io:get_line("") of
        eof ->
            io:format("~n",[]);
        Line ->
            Regex = pattern_to_regex(Pattern),
            Command = "echo '" ++ Line ++ "' | ./priv/bin/pcre2grep '" ++ Regex ++ "'",
            Output = os:cmd(Command),
            io:format("~p~n", [Output]),
            main([Pattern])
    end;
main(_) ->
    usage().

usage() ->
    io:format("Usage: program [PATTERN] ...\n"),
    io:format("\n"),
    io:format("       where PATTERN consists of text literals and\n"),
    io:format("       zero or more token capture sequences.\n"),
    halt(1).

pattern_to_regex(Pattern) ->
    Tokens = string:lexemes(Pattern, " \n"),
    % io:format("~p~n", [Tokens]),
    Regexes = lists:map(fun token_to_regex/1, Tokens),
    % io:format("~p~n", [Regexes]),
    "^" ++ string:join(Regexes, " ") ++ "$".

token_to_regex([$%, ${|_] = PossibleTCS) ->
    % io:format("~p~n", [PossibleTCS]),
    tcs_to_regex(PossibleTCS);
token_to_regex({non_or_malformed_tcs, Literal}) ->
    Literal;
token_to_regex(Literal) ->
    Literal.

% Cannot simply  pattern-match because the input  is a
% string and, according to  the syntax spec, the first
% part has to be a non-negative integer.
tcs_to_regex([$%, ${ | Rest] = PossibleTCS) ->
    case lists:reverse(Rest) of
        % Or use `lists:last/1`.
        [$}|T] ->
            TCSInternals = lists:reverse(T),
    % io:format("TCSInternals: ~p~n", [TCSInternals]),
            parse_tcs_internals(TCSInternals, PossibleTCS);
        _ ->
            Warning =
                "Warning: Token capture sequence \"~p\" possibly missing\n" ++
                "         closing \"}\". Treating token as text literal.\n",
            io:format(standard_error, Warning, [PossibleTCS]),

            token_to_regex({non_or_malformed_tcs, PossibleTCS})
    end.

parse_tcs_internals(Inner, Original) ->

    BaseTCSRegex = "\\b(.*)\\b",

    case string:to_integer(Inner) of
        {error, _} ->
            % TODO: Emit warning.
            token_to_regex({non_or_malformed_tcs, Original});
        % Ignoring the TCS integer for now (the spec also
        % didn't specify further constraints), but making
        % sure that the TCS syntax is correct.
        {_, []} ->
            % io:format("itt~n", []),
            BaseTCSRegex;
        {_, [$G]} ->
            BaseTCSRegex;
        {_, [$S|_]} ->
            parse_s_modifier(Inner, Original);
        _ ->
            % TODO: Emit warning.
            token_to_regex({non_or_malformed_tcs, Original})
    end.

parse_s_modifier([_, $S | []], Original) ->
    % TODO: Emit warning.
    token_to_regex({non_or_malformed_tcs, Original});
parse_s_modifier([_, $S | Limiter], Original) ->

    case string:to_integer(Limiter) of
        {error, _} ->
            % TODO: Emit warning.
            token_to_regex({non_or_malformed_tcs, Original});
        {Int, []} ->
            make_s_regex(Int);
        % If there is anything else than an int,
        % it means that the TCS is malformed.
        _ ->
            % TODO: Emit warning.
            token_to_regex({non_or_malformed_tcs, Original})
    end.

make_s_regex(Int) ->
    "\\b(" ++ do_make_s_regex(Int) ++ ")\\b".

do_make_s_regex(0) ->
    "\\S+";
do_make_s_regex(Int) ->
    do_make_s_regex(Int-1) ++ "\\s{1}\\S+".

% 1> L = string:split("foo %{0} is a %{1}", " ", all).
% ["foo","%{0}","is","a","%{1}"]
% 2> R = lists:map(fun([$%|_] = S) -> "\\b(.*)\\b"; (Literal) -> Literal end, L).
% ["foo","\\b(.*)\\b","is","a","\\b(.*)\\b"]
% 3> os:cmd("echo 'foo blah is a bar' | ./priv/bin/pcre2grep '^" ++ string:join(R, " ") ++ "$'").
% "foo blah is a bar\n"
